{{- $context := import "context" -}}
{{- $cff := import "go.uber.org/cff" -}}
{{- $parallel := .Parallel -}}
{{- with .Parallel -}}
func(
	ctx {{ $context }}.Context,
	emitter {{ $cff }}.Emitter,
) (err error) {
	var (
		parallelInfo = &{{ $cff }}.ParallelInfo{
			{{ with $parallel.Instrument -}}
				Name: {{ rawExpr .Name }},
			{{ end -}}
			File: {{ quote $parallel.PosInfo.File}},
			Line: {{ $parallel.PosInfo.Line }},
			Column: {{ $parallel.PosInfo.Column}},
		}
		directiveInfo = &{{ $cff }}.DirectiveInfo{
			Name: parallelInfo.Name,
			Directive: cff.ParallelDirective,
			File: parallelInfo.File,
			Line: parallelInfo.Line,
			Column: parallelInfo.Column,
		}
		{{ with $parallel.Instrument -}}
			parallelEmitter = emitter.ParallelInit(parallelInfo)
		{{- else -}}
			parallelEmitter = {{ $cff }}.NopParallelEmitter()
		{{- end }}

		schedInfo = &{{ $cff }}.SchedulerInfo{
			Name: parallelInfo.Name,
			Directive: {{ $cff }}.ParallelDirective,
			File: parallelInfo.File,
			Line: parallelInfo.Line,
			Column: parallelInfo.Column,
		}

		// possibly unused
		_ = parallelInfo
		_ = directiveInfo
	)

	startTime := {{ import "time" }}.Now()
	defer func() { parallelEmitter.ParallelDone(ctx, time.Since(startTime)) }()

	schedEmitter := emitter.SchedulerInit(schedInfo)

	sched := {{ $cff }}.BeginFlow(
		{{ $cff }}.SchedulerParams{
			{{ with .Concurrency -}} Concurrency:  {{ rawExpr . }}, {{- end -}}
			Emitter: schedEmitter,
			{{ with .ContinueOnError -}} ContinueOnError: {{ rawExpr . }}, {{ end }}
		},
	)

	type task struct {
		emitter {{ $cff }}.TaskEmitter
		fn func({{ $context }}.Context) error
		ran {{ $cff }}.AtomicBool
	}

	var tasks []*task
	defer func() {
		for _, t := range tasks {
			if !t.ran.Load() {
				t.emitter.TaskSkipped(ctx, err)
			}
		}
	}()

	{{ range $parallel.Tasks }}
		{{ template "task.go.tmpl" . }}
	{{ end }}

	{{ range $parallel.SliceTasks }}
		{{ template "slice.go.tmpl" . }}
	{{ end }}

	{{ range $parallel.MapTasks }}
		{{ template "map.go.tmpl" . }}
	{{ end }}

	if err := sched.Wait(ctx); err != nil {
		parallelEmitter.ParallelError(ctx, err)
		return err
	}
	parallelEmitter.ParallelSuccess(ctx)
	return nil
}(
	{{ rawExpr .Ctx }},
	{{ template "buildEmitter" $parallel }},
)
{{- end -}}

{{- /* vim:set ft=gotexttmpl noet: */ -}}
