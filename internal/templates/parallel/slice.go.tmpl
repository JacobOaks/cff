{{- $context := import "context" -}}
{{- $cff := import "go.uber.org/cff" -}}
{{- $t := printf "sliceTask%d" .Serial -}}

// {{ .PosInfo.File }}:{{ .PosInfo.Line }}:{{ .PosInfo.Column }}
{{ $t }}Slice := {{ expr .Slice }}
{{ if .SliceEndFn -}}
{{ $t }}Jobs := make([]*{{ $cff }}.ScheduledJob, len({{ $t }}Slice))
{{ end -}}

for idx, val := range {{ $t }}Slice {
	idx := idx
	val := val
	{{ $t }} := new({{ template "task" }})
	{{ $t }}.fn = func(ctx {{ $context }}.Context) (err error) {
		defer func() {
			recovered := recover()
			if recovered != nil {
				err = {{ import "fmt" }}.Errorf("panic: %v", recovered)
			}
		}()

	{{ if .Function.HasError }} err = {{ end }}{{ template "callSlice" . }}
		return
	}
	{{ if .SliceEndFn -}}
	 	{{ $t }}Jobs[idx] =
	{{- end -}}
	 sched.Enqueue(ctx, {{ $cff }}.Job{
		Run: {{ $t }}.fn,
	})
}

{{ with .SliceEndFn -}}
	sched.Enqueue(ctx,  {{ $cff }}.Job{
		Dependencies: {{ $t }}Jobs,
		Run: func(ctx {{ $context }}.Context) (err error) {
			defer func() {
				recovered := recover()
				if recovered != nil {
					err = {{ import "fmt" }}.Errorf("panic: %v", recovered)
				}
			}()

			{{ template "callSliceEndFn" . }}
			return
		},
	})
{{ end }}

{{- define "callSlice" -}}
	{{- expr .Function.Node }}({{- if .Function.WantCtx }}ctx,{{ end }} idx, val)
{{- end -}}

{{- define "callSliceEndFn" -}}
	{{ if .HasError }} err = {{ end }}{{- expr .Node }}({{- if .WantCtx }}ctx,{{ end }})
{{- end -}}

{{- /* vim:set ft=gotexttmpl noet: */ -}}
