{{- $context := import "context" -}}
{{- $schedule := .Flow.Schedule -}}
{{- $flow := .Flow -}}
{{- with .Flow -}}
{{- $cff := import "go.uber.org/cff" -}}
func(
	ctx {{ $context }}.Context,
	emitter {{ $cff }}.Emitter,
	{{ range .Inputs -}}
		v{{ typeHash .Type }} {{ type .Type }},
	{{- end }}
) (err error) {
	var _ = ({{ $cff }}.FlowOption)(nil)

	flowInfo := &{{ $cff }}.FlowInfo{
		{{ with $flow.Instrument -}}
			Flow: {{ expr .Name }},
		{{ end -}}
		File: {{ quote $flow.PosInfo.File}},
		Line: {{ $flow.PosInfo.Line }},
		Column: {{ $flow.PosInfo.Column}},
	}
	_ = flowInfo // prevent variable unused errors

	{{ if $flow.Instrument }}
		flowEmitter := emitter.FlowInit(flowInfo)

		startTime := {{ import "time" }}.Now()
		defer func() { flowEmitter.FlowDone(ctx, time.Since(startTime)) }()
	{{- end }}

	type task struct {
		name string
		taskEmitter {{ $cff }}.TaskEmitter
		ran bool
	}

	tasks := [][]*task{
		{{ range $schedule -}}
			{
				{{ range . -}}
					{
						{{ if .Instrument -}}
							name: {{ expr .Instrument.Name }},
							taskEmitter: emitter.TaskInit(
								&{{ $cff }}.TaskInfo{
									Task: {{ expr .Instrument.Name }},
									File: {{ quote .PosInfo.File}},
									Line: {{ .PosInfo.Line }},
									Column: {{ .PosInfo.Column}},
								},
								flowInfo,
							),
						{{- end }}
						ran: false,
					},
				{{ end }}
			},
		{{ end }}
	}

	defer func() {
		for _, sched := range tasks {
			for _, task := range sched {
				if task.name == "" || task.ran { continue }
				task.taskEmitter.TaskSkipped(ctx, err)
			}
		}
		{{- if $flow.Instrument }}
			if err != nil {
				flowEmitter.FlowSkipped(ctx, err)
			}
		{{ end }}
	}()

	{{ range $schedIdx, $sched := $schedule }}
		if ctx.Err() != nil {
			return ctx.Err()
		}

		{{- $once := printf "once%v" $schedIdx -}}
		{{- $wg := printf "wg%v" $schedIdx -}}
		{{- $sync := import "sync" -}}
		{{- $hasMultipleTasks := ne 1 (len $sched) }}
		var (
			{{ if $hasMultipleTasks }}
				{{ $wg }} {{ $sync }}.WaitGroup
			{{ end }}
			{{ $once }} {{ $sync }}.Once
		)

		{{ if $hasMultipleTasks }}
			{{ $wg }}.Add({{ len . }})
		{{ end }}

		{{ range $taskIdx, $task := $sched }}
			{{- $serr := printf "err%v" .Serial -}}
			{{ template "taskResultVarDecl" . }}
			{{ if $hasMultipleTasks -}}
			go func() {
				defer {{ $wg }}.Done()
			{{ else -}}
			func() {
			{{ end -}}

				{{ if .Instrument -}}
					taskEmitter := tasks[{{ $schedIdx }}][{{ $taskIdx }}].taskEmitter
					startTime := {{ import "time" }}.Now()
					defer func() { taskEmitter.TaskDone(ctx, time.Since(startTime)) }()
				{{- end }}
				defer func() {
					recovered := recover()
					if recovered != nil {
					{{ if .FallbackWith }}
						{{ if .Instrument -}}
							taskEmitter.TaskPanicRecovered(ctx, recovered)
						{{ end -}}
						{{ template "taskResultList" . }} = {{ range $i, $v := .FallbackWithResults -}}
							{{ if gt $i 0 }},{{ end }}{{ expr $v }}
						{{- end }}{{ if gt (len .FallbackWithResults) 0 }}, {{ end }} nil
					{{ else }}
						{{ $fmt := import "fmt" }}
						{{ $once }}.Do(func() {
							recoveredErr := {{ $fmt }}.Errorf("task panic: %v", recovered)
							{{ if .Instrument -}}
								taskEmitter.TaskPanic(ctx, recovered)
							{{- end }}
							err = recoveredErr
						})
					{{ end }}
					}
				}()

				{{ if .Predicate }}
					if {{ template "callTask" .Predicate }} {
				{{ end }}

					{{ template "taskResultList" . }}{{ if or .HasError (len .Outputs) }} = {{ end }}{{ template "callTask" . }}

					tasks[{{ $schedIdx }}][{{ $taskIdx }}].ran = true
					{{ if .HasError -}}
						if {{ $serr }} != nil {
							{{ if .FallbackWith -}}
								{{ if .Instrument -}}
									taskEmitter.TaskErrorRecovered(ctx, {{$serr}})
								{{- end }}

								{{ template "taskResultList" . }} = {{ range $i, $v := .FallbackWithResults -}}
									{{ if gt $i 0 }},{{ end }}{{ expr $v }}
								{{- end }}{{ if gt (len .FallbackWithResults) 0 }}, {{ end }} nil
							{{- else -}}
								{{ if .Instrument -}}
									taskEmitter.TaskError(ctx, {{$serr}})
								{{- end }}
								{{ $once }}.Do(func() { err = {{ $serr }} })
							{{- end }}
						} {{ if .Instrument }} else {
							taskEmitter.TaskSuccess(ctx)
						} {{ end }}
					{{ else }} {{/* cannot return error */}}
					{{ if .Instrument -}}
						taskEmitter.TaskSuccess(ctx)
					{{- end }}
					{{ end }}
				{{ if .Predicate }}
					}
				{{ end }}
			}()
		{{ end }}

		{{ if $hasMultipleTasks }}
			{{ $wg }}.Wait()
		{{ end -}}
		if err != nil {
			{{ if $flow.Instrument -}}
				flowEmitter.FlowError(ctx, err)
			{{- end }}
			return err
		}

		// Prevent variable unused errors.
		var (
			_ = &{{ $once }}
			{{ range . -}}
				{{ range .Outputs -}}
					_ = &v{{ typeHash .}}
				{{ end -}}
			{{ end }}
		)
	{{ end }}

	{{ range .Outputs }}
		*({{ expr .Node }}) = v{{ typeHash .Type }}
	{{- end }}

	{{ if $flow.Instrument -}}
		if err != nil {
			flowEmitter.FlowError(ctx, err)
		} else {
			flowEmitter.FlowSuccess(ctx)
		}
	{{- end }}

	return err
}(
	{{ expr .Ctx }},
	{{ template "buildEmitter" $flow }},
	{{ range .Inputs -}}
		{{ expr .Node }},
	{{ end }}
)
{{- end -}}

{{- define "buildEmitter" -}}
	{{- $cff :=  import "go.uber.org/cff" -}}
	{{- with .Emitters -}}
		{{ $cff }}.EmitterStack(
			{{- range . -}}
				{{ expr . }},
			{{- end -}}
		)
	{{- else -}}
		{{ $cff }}.NopEmitter()
	{{- end -}}
{{- end -}}

{{- define "taskResultVarDecl" -}}
	{{ range .Outputs }}
		var v{{ typeHash . }} {{ type . }}
	{{- end }}
	{{ if .HasError }}var {{ printf "err%d" .Serial }} error{{ end }}
{{- end -}}

{{- define "taskResultList" -}}
	{{- range $i, $t := .Outputs -}}
		{{ if gt $i 0 }},{{ end }}v{{ typeHash $t }}
	{{- end }}{{ if .HasError }}{{ if len .Outputs }}, {{ end }}{{ printf "err%d" .Serial }}{{ end }}
{{- end -}}

{{- define "callTask" -}}
	{{- expr .Node }}({{- if .WantCtx }}ctx,{{ end }} {{- range .Inputs }}v{{ typeHash . }}, {{- end }})
{{- end -}}

{{- /* vim:set ft=gotexttmpl noet: */ -}}
