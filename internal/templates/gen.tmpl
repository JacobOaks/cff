{{- $context := import "context" -}}
{{- $schedule := .Flow.Schedule -}}
{{- $flow := .Flow -}}
{{- with .Flow -}}
    func(ctx {{ $context }}.Context,
    {{- $cff := import "go.uber.org/cff" -}}
    {{- if $flow.ObservabilityEnabled -}}
        {{- $zap := import "go.uber.org/zap" -}}
        emitter {{ $cff }}.Emitter,
        logger *{{ $zap }}.Logger,
    {{- end -}}
    {{- range .Inputs -}}
        v{{ typeHash .Type }} {{ type .Type }},
    {{- end }}) (err error) {
    var _ = ({{ $cff }}.FlowOption)(nil)
    {{ if $flow.ObservabilityEnabled }}
        {{ with $flow.LogFields }}
        logger = logger.With(
            {{- range $i, $f := .Args }}
                {{- if $i }},{{ end -}} {{ expr $f }}
            {{- end }}{{ if .Ellipsis }}...{{ end }})
        {{ end }}
    {{ end }}
    {{ if $flow.Instrument }}
        var flowEmitterReplace sync.Once
        var _ = &flowEmitterReplace
        flowEmitter := emitter.FlowInit(
            &{{ $cff }}.FlowInfo{
                Flow: {{ expr $flow.Instrument.Name }},
                File: {{ quote $flow.PosInfo.File}},
                Line: {{ $flow.PosInfo.Line }},
                Column: {{ $flow.PosInfo.Column}},
            },
        )
        startTime := {{ import "time" }}.Now()
        defer func() { flowEmitter.FlowDone(ctx, time.Since(startTime)) }()
    {{- end }}
    {{- if $flow.ObservabilityEnabled }}
        type task struct {
        name string
        taskEmitter {{ $cff }}.TaskEmitter
        ran bool
        }

        tasks := [][]*task{
        {{ range $schedule -}}
            {
            {{ range . -}}
                {
                {{ if .Instrument -}}
                    name: {{ expr .Instrument.Name }},
                    taskEmitter: emitter.TaskInit(
                        &{{ $cff }}.TaskInfo{
                            Task: {{ expr .Instrument.Name }},
                            File: {{ quote .PosInfo.File}},
                            Line: {{ .PosInfo.Line }},
                            Column: {{ .PosInfo.Column}},
                    },
                    &{{ $cff }}.FlowInfo{
                    {{- if $flow.Instrument }}
                    Flow: {{ expr $flow.Instrument.Name }},
                    {{ else }}
                    Flow: "",
                    {{- end }}
                    File: {{ quote $flow.PosInfo.File}},
                    Line: {{ $flow.PosInfo.Line }},
                    Column: {{ $flow.PosInfo.Column}},
                    },
                    ),
                {{- end }}
                ran: false,
                },
            {{ end }}
            },
        {{ end }}
        }
        defer func() {
        for _, sched := range tasks {
        for _, task := range sched {
        if task.name == "" || task.ran { continue }
        task.taskEmitter.TaskSkipped(ctx, err)
        if err == nil {
        logger.Debug("task skipped", zap.String("task", task.name))
        } else {
        logger.Debug("task skipped", zap.String("task", task.name), zap.Error(err))
        }
        }
        }
        {{- if $flow.Instrument }}
            if err != nil {
            flowEmitter.FlowSkipped(ctx, err)
            logger.Debug("taskflow skipped", zap.String("flow", {{ expr $flow.Instrument.Name }}), zap.Error(err))
            }
        {{ end }}
        }()
    {{ end }}

    {{ range $schedIdx, $sched := $schedule }}
        if ctx.Err() != nil {
        return ctx.Err()
        }

        {{- $once := printf "once%v" $schedIdx -}}
        {{- $wg := printf "wg%v" $schedIdx -}}
        {{- $sync := import "sync" -}}
        {{- $hasMultipleTasks := ne 1 (len $sched) }}
        var (
        {{ if $hasMultipleTasks }}
            {{ $wg }} {{ $sync }}.WaitGroup
        {{ end }}
        {{ $once }} {{ $sync }}.Once
        )

        {{ if $hasMultipleTasks }}
            {{ $wg }}.Add({{ len . }})
        {{ end }}

        {{ range $taskIdx, $task := $sched }}
            {{- $serr := printf "err%v" .Serial -}}
            {{ template "taskResultVarDecl" . }}
            {{ if $hasMultipleTasks -}}
                go func() {
                defer {{ $wg }}.Done()
            {{ else -}}
                func() {
            {{ end -}}

            {{ if .Instrument -}}
            taskEmitter := tasks[{{ $schedIdx }}][{{ $taskIdx }}].taskEmitter
            startTime := {{ import "time" }}.Now()
            defer func() { taskEmitter.TaskDone(ctx, time.Since(startTime)) }()
            {{- end }}
            defer func() {
            recovered := recover()
            if recovered != nil {
            {{ if .FallbackWith }}
                {{ if .Instrument -}}
                    taskEmitter.TaskPanic(ctx, recovered)
                    taskEmitter.TaskRecovered(ctx, recovered)
                    recoveredErr, ok := recovered.(error)
                    if ok {
                    logger.Error("task panic recovered",
                    zap.String("task", {{ expr .Instrument.Name }}),
                    zap.Stack("stack"),
                    zap.Error(recoveredErr))
                    } else {
                    logger.Error("task panic recovered",
                    zap.String("task", {{ expr .Instrument.Name }}),
                    zap.Stack("stack"),
                    zap.Any("recoveredValue", recovered))
                    }
                {{ end -}}
                {{ template "taskResultList" . }} = {{ range $i, $v := .FallbackWithResults -}}
                    {{ if gt $i 0 }},{{ end }}{{ expr $v }}
                {{- end }}{{ if gt (len .FallbackWithResults) 0 }}, {{ end }} nil
            {{ else }}
                {{ $fmt := import "fmt" }}
                {{ $once }}.Do(func() {
                recoveredErr := {{ $fmt }}.Errorf("task panic: %v", recovered)
                {{ if .Instrument -}}
                    taskEmitter.TaskPanic(ctx, recovered)
                    logger.Error("task panic",
                    zap.String("task", {{ expr .Instrument.Name }}),
                    zap.Stack("stack"),
                    zap.Error(recoveredErr))
                {{- end }}
                err = recoveredErr
                })
            {{ end }}
            }
            }()

            {{ if .Predicate }}
                if {{ template "callTask" .Predicate }} {
            {{ end }}
            {{ template "taskResultList" . }}{{ if or .HasError (len .Outputs) }} = {{ end }}{{ template "callTask" . }}

            {{- if $flow.ObservabilityEnabled }}
                tasks[{{ $schedIdx }}][{{ $taskIdx }}].ran = true
            {{- end }}
            {{ if .HasError -}}
                if {{ $serr }} != nil {
                {{ if .FallbackWith -}}
                    {{ if .Instrument -}}
                        taskEmitter.TaskError(ctx, {{$serr}})
                        taskEmitter.TaskRecovered(ctx, {{$serr}})
                        logger.Error("task error recovered",
                        zap.String("task", {{ expr .Instrument.Name }}),
                        zap.Error({{ $serr }}),
                        )
                    {{- end }}

                    {{ template "taskResultList" . }} = {{ range $i, $v := .FallbackWithResults -}}
                        {{ if gt $i 0 }},{{ end }}{{ expr $v }}
                    {{- end }}{{ if gt (len .FallbackWithResults) 0 }}, {{ end }} nil
                {{- else -}}
                    {{ if .Instrument -}}
                        {{ if $flow.Instrument -}}
                            flowEmitterReplace.Do(func() {
                                flowEmitter = flowEmitter.FlowFailedTask(ctx, {{ expr .Instrument.Name }}, {{$serr}})
                            })
                        {{- end }}
                        taskEmitter.TaskError(ctx, {{$serr}})
                    {{- end }}
                    {{ $once }}.Do(func() {
                    err = {{ $serr }}
                    })
                {{- end }}
                } {{ if .Instrument }} else {
                taskEmitter.TaskSuccess(ctx)
                logger.Debug("task succeeded", zap.String("task", {{ expr .Instrument.Name }}))
                } {{ end }}
            {{ else }} {{/* cannot return error */}}
            {{ if .Instrument -}}
                taskEmitter.TaskSuccess(ctx)
                logger.Debug("task succeeded", zap.String("task", {{ expr .Instrument.Name }}))
            {{- end }}
            {{ end }}
            {{ if .Predicate }}
                }
            {{ end }}
            }()
        {{ end }}

        {{ if $hasMultipleTasks }}
            {{ $wg }}.Wait()
        {{ end -}}
        if err != nil {
        {{ if $flow.Instrument -}}
                flowEmitter.FlowError(ctx, err)
        {{- end }}
        return err
        }

        // Prevent variable unused errors.
        var (
        _ = &{{ $once }}
        {{ range . -}}
            {{ range .Outputs -}}
                _ = &v{{ typeHash .}}
            {{ end -}}
        {{ end }}
        )
    {{ end }}

    {{ range .Outputs }}
        *({{ expr .Node }}) = v{{ typeHash .Type }}
    {{- end }}

    {{ if $flow.Instrument -}}
        if err != nil {
            flowEmitter.FlowError(ctx, err)
        } else {
                flowEmitter.FlowSuccess(ctx)
            logger.Debug("taskflow succeeded", zap.String("flow", {{ expr $flow.Instrument.Name }}))
        }
    {{- end }}

    return err
    }({{ expr .Ctx }}{{ if $flow.ObservabilityEnabled }}, {{ template "buildEmitter" $flow }}, {{ expr $flow.Logger }} {{ end }}{{ range .Inputs }}, {{ expr .Node }}{{ end }})
{{- end -}}

{{/* Builds a cff.Emitter for a flow. */}}
{{- define "buildEmitter" -}}
    {{- if .Emitter -}}
        {{ expr .Emitter }}
    {{- else -}}
        {{- $cff := import "go.uber.org/cff" -}}
        {{ $cff }}.DefaultEmitter({{ expr .Metrics }})
    {{- end -}}
{{- end -}}

{{- define "taskResultVarDecl" -}}
    {{ range .Outputs }}
        var v{{ typeHash . }} {{ type . }}
    {{- end }}
    {{ if .HasError }}var {{ printf "err%d" .Serial }} error{{ end }}
{{- end -}}

{{- define "taskResultList" -}}
    {{- range $i, $t := .Outputs -}}
        {{ if gt $i 0 }},{{ end }}v{{ typeHash $t }}
    {{- end }}{{ if .HasError }}{{ if len .Outputs }}, {{ end }}{{ printf "err%d" .Serial }}{{ end }}
{{- end -}}

{{- define "callTask" -}}
    {{- expr .Node }}({{- if .WantCtx }}ctx,{{ end }} {{- range .Inputs }}v{{ typeHash . }}, {{- end }})
{{- end -}}
