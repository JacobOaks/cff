{{- $context := import "context" -}}
{{- $sync := import "sync" -}}
{{- $schedule := .Flow.Schedule -}}
{{- $flow := .Flow -}}
{{- with .Flow -}}
{{- $cff := import "go.uber.org/cff" -}}
func(
	ctx {{ $context }}.Context,
	emitter {{ $cff }}.Emitter,
	{{ range .Inputs -}}
		v{{ typeHash .Type }} {{ type .Type }},
	{{- end }}
) (err error) {
	var (
		flowInfo = &{{ $cff }}.FlowInfo{
			{{ with $flow.Instrument -}}
				Flow: {{ expr .Name }},
			{{ end -}}
			File: {{ quote $flow.PosInfo.File}},
			Line: {{ $flow.PosInfo.Line }},
			Column: {{ $flow.PosInfo.Column}},
		}
		{{ if $flow.Instrument -}}
			flowEmitter = emitter.FlowInit(flowInfo)
		{{- else -}}
			flowEmitter = {{ $cff }}.NopFlowEmitter()
		{{- end }}

		// possibly unused
		_ = flowInfo
	)

	startTime := {{ import "time" }}.Now()
	defer func() { flowEmitter.FlowDone(ctx, time.Since(startTime)) }()

	type task struct {
		emitter {{ $cff }}.TaskEmitter
		ran bool
		run func({{ $context }}.Context) error
	}

	var tasks []*task
	defer func() {
		for _, t := range tasks {
			if !t.ran {
				t.emitter.TaskSkipped(ctx, err)
			}
		}

		if err != nil {
			flowEmitter.FlowSkipped(ctx, err)
		}
	}()

	{{/*
	  Declare output variables for each task so that the order in which
	  task.run functions are declared is irrelevant.
	*/}}
	{{ with $flow.Tasks -}}
		var (
			{{ range . }}
				{{- $t := . -}}
				{{- range .Outputs -}}
					v{{ typeHash . }} {{ type . }} // from {{ printf "task%d" $t.Serial }}
				{{ end -}}
			{{ end }}
		)
	{{- end }}

	{{ range $flow.Tasks -}}
		{{ $t := printf "task%d" .Serial }}

		// {{ .PosInfo.File }}:{{ .PosInfo.Line }}:{{ .PosInfo.Column }}
		{{ $t }} := new(task)
		tasks = append(tasks, {{ $t }})
		{{ $t }}.emitter =
			{{- if .Instrument -}}
				emitter.TaskInit(
					&{{ $cff }}.TaskInfo{
						Task: {{ expr .Instrument.Name }},
						File: {{ quote .PosInfo.File}},
						Line: {{ .PosInfo.Line }},
						Column: {{ .PosInfo.Column}},
					},
					flowInfo,
				)
			{{- else -}}
				{{ $cff }}.NopTaskEmitter()
			{{- end }}
		{{ $t }}.run = func(ctx {{ $context }}.Context) (err error) {
			taskEmitter := {{ $t }}.emitter
			startTime := {{ import "time" }}.Now()
			defer func() { taskEmitter.TaskDone(ctx, time.Since(startTime)) }()

			defer func() {
				recovered := recover()
				if recovered != nil {
				{{ if .FallbackWith -}}
					taskEmitter.TaskPanicRecovered(ctx, recovered)
					{{ template "taskResultList" . }} = {{ range $i, $v := .FallbackWithResults -}}
						{{ if gt $i 0 }},{{ end }}{{ expr $v }}
					{{- end }}{{ if gt (len .FallbackWithResults) 0 }}, {{ end }} nil
				{{- else -}}
					taskEmitter.TaskPanic(ctx, recovered)
					err = {{ import "fmt" }}.Errorf("task panic: %v", recovered)
				{{- end }}
				}
			}()

			{{ if .Predicate }}
				if !({{ template "callTask" .Predicate }}) {
					return nil
				}
			{{ end }}

			{{ template "taskResultList" . }}{{ if or .HasError (len .Outputs) }} = {{ end }}{{ template "callTask" . }}
			{{ $t }}.ran = true

			{{ if .HasError -}}
				if err != nil {
					{{- if .FallbackWith -}}
						taskEmitter.TaskErrorRecovered(ctx, err)
						{{ template "taskResultList" . }} = {{ range $i, $v := .FallbackWithResults -}}
							{{ if gt $i 0 }},{{ end }}{{ expr $v }}
						{{- end }}{{ if gt (len .FallbackWithResults) 0 }}, {{ end }} nil
					{{- else -}}
						taskEmitter.TaskError(ctx, err)
						return err
					{{- end }}
				} else {
					taskEmitter.TaskSuccess(ctx)
				}
			{{- else -}}
				taskEmitter.TaskSuccess(ctx)
			{{- end }}

			return
		}
	{{ end }}

	schedule := [][]*task{
		{{ range $schedule -}}
			{
				{{- range . -}}
					{{ printf "task%d" .Serial }},
				{{- end -}}
			},
		{{ end -}}
	}

	for _, taskGroup := range schedule {
		if err := ctx.Err(); err != nil  {
			return err
		}

		if len(taskGroup) == 1 {
			if err := taskGroup[0].run(ctx); err != nil {
				flowEmitter.FlowError(ctx, err)
				return err
			}
			continue
		}

		var (
			wg {{ $sync }}.WaitGroup
			once {{ $sync }}.Once
			err error
		)

		wg.Add(len(taskGroup))
		for _, t := range taskGroup {
			go func(t *task) {
				defer wg.Done()
				if terr := t.run(ctx); terr != nil {
					once.Do(func() {
						err = terr
					})
				}
			}(t)
		}

		wg.Wait()

		if err != nil {
			flowEmitter.FlowError(ctx, err)
			return err
		}
	}

	{{ range .Outputs }}
		*({{ expr .Node }}) = v{{ typeHash .Type }} // {{ typeName .Type }}
	{{- end }}

	flowEmitter.FlowSuccess(ctx)
	return nil
}(
	{{ expr .Ctx }},
	{{ template "buildEmitter" $flow }},
	{{ range .Inputs -}}
		{{ expr .Node }},
	{{ end }}
)
{{- end -}}

{{- define "buildEmitter" -}}
	{{- $cff :=  import "go.uber.org/cff" -}}
	{{- with .Emitters -}}
		{{ $cff }}.EmitterStack(
			{{- range . -}}
				{{ expr . }},
			{{- end -}}
		)
	{{- else -}}
		{{ $cff }}.NopEmitter()
	{{- end -}}
{{- end -}}

{{- define "taskResultList" -}}
	{{- range $i, $t := .Outputs -}}
		{{ if gt $i 0 }},{{ end }}v{{ typeHash $t }}
	{{- end }}{{ if .HasError }}{{ if len .Outputs }}, {{ end }}err{{ end }}
{{- end -}}

{{- define "callTask" -}}
	{{- expr .Node }}({{- if .WantCtx }}ctx,{{ end }} {{- range .Inputs }}v{{ typeHash . }}, {{- end }})
{{- end -}}

{{- /* vim:set ft=gotexttmpl noet: */ -}}
