{{- $context := import "context" -}}
{{- $schedule := .Flow.Schedule -}}
{{- $flow := .Flow -}}
{{- with .Flow -}}
{{- $cff := import "go.uber.org/cff" -}}
func(
	ctx {{ $context }}.Context,
	emitter {{ $cff }}.Emitter,
	{{ range .Inputs -}}
		v{{ typeHash .Type }} {{ type .Type }},
	{{- end }}
) (err error) {
	var _ = ({{ $cff }}.FlowOption)(nil)

	flowInfo := &{{ $cff }}.FlowInfo{
		{{ with $flow.Instrument -}}
			Flow: {{ expr .Name }},
		{{ end -}}
		File: {{ quote $flow.PosInfo.File}},
		Line: {{ $flow.PosInfo.Line }},
		Column: {{ $flow.PosInfo.Column}},
	}
	_ = flowInfo // prevent variable unused errors

	{{ if $flow.Instrument -}}
		flowEmitter := emitter.FlowInit(flowInfo)
	{{- else -}}
		flowEmitter := {{ $cff }}.NopFlowEmitter()
	{{- end }}

	startTime := {{ import "time" }}.Now()
	defer func() { flowEmitter.FlowDone(ctx, time.Since(startTime)) }()

	type task struct {
		emitter {{ $cff }}.TaskEmitter
		ran bool
	}

	tasks := [][]*task{
		{{ range $schedule -}}
			{
				{{ range . -}}
					{
						{{ if .Instrument -}}
							emitter: emitter.TaskInit(
								&{{ $cff }}.TaskInfo{
									Task: {{ expr .Instrument.Name }},
									File: {{ quote .PosInfo.File}},
									Line: {{ .PosInfo.Line }},
									Column: {{ .PosInfo.Column}},
								},
								flowInfo,
							),
						{{- else -}}
							emitter: {{ $cff }}.NopTaskEmitter(),
						{{- end }}
						ran: false,
					},
				{{ end }}
			},
		{{ end }}
	}

	defer func() {
		for _, sched := range tasks {
			for _, task := range sched {
				if !task.ran {
					task.emitter.TaskSkipped(ctx, err)
				}
			}
		}

		if err != nil {
			flowEmitter.FlowSkipped(ctx, err)
		}
	}()

	{{ range $schedIdx, $sched := $schedule }}
		if ctx.Err() != nil {
			return ctx.Err()
		}

		{{- $once := printf "once%v" $schedIdx -}}
		{{- $wg := printf "wg%v" $schedIdx -}}
		{{- $sync := import "sync" -}}
		{{- $hasMultipleTasks := ne 1 (len $sched) }}
		var (
			{{ if $hasMultipleTasks }}
				{{ $wg }} {{ $sync }}.WaitGroup
			{{ end }}
			{{ $once }} {{ $sync }}.Once
		)

		{{ if $hasMultipleTasks }}
			{{ $wg }}.Add({{ len . }})
		{{ end }}

		{{ range $taskIdx, $task := $sched }}
			{{- $serr := printf "err%v" .Serial -}}
			{{ template "taskResultVarDecl" . }}
			{{ if $hasMultipleTasks -}}
			go func() {
				defer {{ $wg }}.Done()
			{{ else -}}
			func() {
			{{ end -}}

				taskEmitter := tasks[{{ $schedIdx }}][{{ $taskIdx }}].emitter
				startTime := {{ import "time" }}.Now()
				defer func() { taskEmitter.TaskDone(ctx, time.Since(startTime)) }()

				defer func() {
					recovered := recover()
					if recovered != nil {
					{{ if .FallbackWith }}
						taskEmitter.TaskPanicRecovered(ctx, recovered)
						{{ template "taskResultList" . }} = {{ range $i, $v := .FallbackWithResults -}}
							{{ if gt $i 0 }},{{ end }}{{ expr $v }}
						{{- end }}{{ if gt (len .FallbackWithResults) 0 }}, {{ end }} nil
					{{ else }}
						{{ $fmt := import "fmt" }}
						{{ $once }}.Do(func() {
							recoveredErr := {{ $fmt }}.Errorf("task panic: %v", recovered)
							taskEmitter.TaskPanic(ctx, recovered)
							err = recoveredErr
						})
					{{ end }}
					}
				}()

				{{ if .Predicate }}
					if {{ template "callTask" .Predicate }} {
				{{ end }}

					{{ template "taskResultList" . }}{{ if or .HasError (len .Outputs) }} = {{ end }}{{ template "callTask" . }}

					tasks[{{ $schedIdx }}][{{ $taskIdx }}].ran = true
					{{ if .HasError -}}
						if {{ $serr }} != nil {
							{{ if .FallbackWith -}}
								taskEmitter.TaskErrorRecovered(ctx, {{$serr}})

								{{ template "taskResultList" . }} = {{ range $i, $v := .FallbackWithResults -}}
									{{ if gt $i 0 }},{{ end }}{{ expr $v }}
								{{- end }}{{ if gt (len .FallbackWithResults) 0 }}, {{ end }} nil
							{{- else -}}
								taskEmitter.TaskError(ctx, {{$serr}})
								{{ $once }}.Do(func() { err = {{ $serr }} })
							{{- end }}
						} else {
							taskEmitter.TaskSuccess(ctx)
						}
					{{ else }} {{/* cannot return error */}}
						taskEmitter.TaskSuccess(ctx)
					{{ end }}
				{{ if .Predicate }}
					}
				{{ end }}
			}()
		{{ end }}

		{{ if $hasMultipleTasks }}
			{{ $wg }}.Wait()
		{{ end -}}
		if err != nil {
			flowEmitter.FlowError(ctx, err)
			return err
		}

		// Prevent variable unused errors.
		var (
			_ = &{{ $once }}
			{{ range . -}}
				{{ range .Outputs -}}
					_ = &v{{ typeHash .}}
				{{ end -}}
			{{ end }}
		)
	{{ end }}

	{{ range .Outputs }}
		*({{ expr .Node }}) = v{{ typeHash .Type }}
	{{- end }}

	if err != nil {
		flowEmitter.FlowError(ctx, err)
	} else {
		flowEmitter.FlowSuccess(ctx)
	}

	return err
}(
	{{ expr .Ctx }},
	{{ template "buildEmitter" $flow }},
	{{ range .Inputs -}}
		{{ expr .Node }},
	{{ end }}
)
{{- end -}}

{{- define "buildEmitter" -}}
	{{- $cff :=  import "go.uber.org/cff" -}}
	{{- with .Emitters -}}
		{{ $cff }}.EmitterStack(
			{{- range . -}}
				{{ expr . }},
			{{- end -}}
		)
	{{- else -}}
		{{ $cff }}.NopEmitter()
	{{- end -}}
{{- end -}}

{{- define "taskResultVarDecl" -}}
	{{ range .Outputs }}
		var v{{ typeHash . }} {{ type . }}
	{{- end }}
	{{ if .HasError }}var {{ printf "err%d" .Serial }} error{{ end }}
{{- end -}}

{{- define "taskResultList" -}}
	{{- range $i, $t := .Outputs -}}
		{{ if gt $i 0 }},{{ end }}v{{ typeHash $t }}
	{{- end }}{{ if .HasError }}{{ if len .Outputs }}, {{ end }}{{ printf "err%d" .Serial }}{{ end }}
{{- end -}}

{{- define "callTask" -}}
	{{- expr .Node }}({{- if .WantCtx }}ctx,{{ end }} {{- range .Inputs }}v{{ typeHash . }}, {{- end }})
{{- end -}}

{{- /* vim:set ft=gotexttmpl noet: */ -}}
